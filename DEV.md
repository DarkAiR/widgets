#### Сборка проекта в npm-пакет

1. Изменяем версию в package-lib.json
2. Дописываем CHANGELOG.md
3. Запускаем npm run postversion

PS. Естественно все это можно автоматизировать через npm publish и собирать логи из коммитов,
    но на это нет времени и это никому не нужно. 

#### Правила разработки библиотеки виджетов

*Правила ниже нужны, в первую очередь, для единства кода при работе нескольких человек.   
Библиотека виджетов не подразумевается к использованию нигде, кроме собственных продуктов компании. Отсюда вытекают, в том числе, условия по стилям, описанные ниже.* 

1. **Библиотека должна быть небольшой, насколько это возможно.** Поэтому не затягиваем никаких лишних библиотек без острой необходимости.
   На данный момент для формирования HTML можно использовать встроенный шаблонизатор, а для внутренней работы с событиями связку ```querySelector + addEventListener```.      
   Текущая проблема - ```echarts``` не проходит этап минификации - требует решения.
   
2. В рамках отдельного виджета программист может самостоятельно решать, как будет построена работа его виджета.   
   Если необходимо, можно затянуть новый npm-пакет, но необходимо согласование (см. п.1)   
   В остальном особых ограничений нет.

3. **Пишем на TypeScript.** Использование нативного JS необосновано ничем, кроме legacy-кода.   
   Портирование кода на TypeScript максимально просто и не вызывает никаких проблем.   
   Если остро необходимо использовать именно JS, то можно решить все или методом require или обернув JS в отдельную библиотеку.   

   *В любом случае все новые виджеты должны наследоваться от конкретного базового класса, что не получится сделать при попытке написать все на JS.*
   
4. **Используем препроцессоры.** В нашем случае LESS. Писать на голом CSS запрещено в силу его очевидных ограничений.   
   Архитектура проекта при этом позволяет использовать CSS с учетом того, что он будет подключен и использован по аналогии с less через ```import```.

5. Использование препроцессоров заставляет программиста писать более осознанный код и пресекает попытки использовать css в виде глобального набора классов, что, очевидно, сломает страницу, на которой будет подключен виджет.   
   Другими словами все это позволяет нам изолировать все стили в рамках конкретных виджетов.
   
6. **Не держим в проекте никаких лишних файлов стилей**.   
   Это нужно для того, чтобы все виджеты выглядели одинаково и не требовали дополнительных include в вызывающих проектах.   
   Единственное исключение - библиотека ```goodt-css-framework```, которая содержит весь набор необходимых css-классов.   
   Т.к. на данный момент ```goodt-css-framework``` используется во всех продуктах, где подключена библиотека виджетов, то в какой-то момент даже она будет исключена из сборки.
   
7. **Для поддержки единых тем** мы не должны использовать сторонние css-стили кроме дефолтных.   
   Это значит, что любые попытки затянуть в проект целиком свой css должны пресекаться на этапе review.
